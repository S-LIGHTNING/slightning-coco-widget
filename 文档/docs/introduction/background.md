---
sidebar_position: 2
---

# 产生背景

:::tip 提示
本文档的内容可以帮助你更好的了解 SCW 的来源、所解决的问题和未来可能的发展方向。
:::

## 一、从手搓控件文件开始

在早期，自定义控件开发靠的是手搓控件文件。控件文件是一个单一的 JS 脚本文件，里面包含了控件所有的功能。那个时候，控件的功能比较简单，直接编写控件文件非常方便。

这样的作法很快就遇到了问题：
- 不同的控件有一些通用的代码，把这些代码来回复制非常麻烦，也不便于管理；
- 在编写复杂功能时，把代码写到都写到一个文件中非常不方便；
- 对于高度动态的 JS 代码，难以进行静态代码分析，一些简单的错误都要运行代码后才能发现，有些功能更新后相应的用法没有及时更新，导致代码出现各种问题。

## 二、通用模块 + 打包工具 + TypeScript 的时代

通用模块、打包工具和 TypeScript 分别解决了上面的三个问题。

将不同控件的公共部分提取为可复用的依赖，避免了这些代码的来回复制；打包工具可以把分文件的代码合成为一个文件，使模块化编写 CoCo 控件成为可能；TypeScript 强大的类型系统，使我们能够利用一些工具高效开发自定义控件。

其中由 SLIGHTNING 所提取的可复用的依赖，就是 SCW 的前身。

这相比手搓控件文件，开发体验已经上升了许多，似乎已经能够满足全部的 CoCo 控件开发需求了。然而，随着时间的推移，我们发现还有一些问题需要解决。

## 三、新的问题

### 1.自动绕过 CoCo 关键词检查

有时候，我们想开发一个 CoCo 控件，它不仅仅是一个 CoCo 控件，同时还可以是一段 node 脚本。也就是说，我们需要编写既能在 CoCo 中运行，又能在 node 中运行的代码。

在编写 CoCo 控件时，我们往往会因为 CoCo 的一些特性写一些针对 CoCo 控件的代码，例如把`WebSocket`写成`this["Web" + "Socket"]`，这样的代码只能在 CoCo 中运行，不能在 node 中运行。也许你注意到把`WebSocket`写成`(new Function("return " + "Web" + "Socket"))()`就能使代码同时在 CoCo 和 node 中运行了。但是，这样做并不优雅。

上面所说的还只是自己编写代码的问题，尚且还可以用一些手段解决。但是，有些 node 模块会使用一些被 CoCo 禁用的 API，想要使用这些库，就不得不修改这些库中的代码以绕过限制，这不仅费时费力，还不利于维护。

我们期待有一种方法，可以让我们在不改变源代码的情况下绕过 CoCo 关键词检查。

### 2.Creation Project 的出现

Creation Project 的出现为自定义控件带来了新的可能。Creation Project 自定义控件拥有更多强大的功能，但是，这些功能只能在 Creation Project 中使用，在 CoCo 中用不了。有没有一种方法，使得我们能够利用 Creation Project 特性的同时兼容 CoCo？

## 四、SCW 出现啦

SCW 就是为了解决上述问题而出现的，具有诸多优点。

### 1.自动绕过 CoCo 自定义控件检查

SCW 通过 webpack 绕过 CoCo 自定义控件检查，无需修改源代码。

### 2.独立于运行平台的控件 API

SCW 独立于运行平台，既可以在 Creation Project 中使用，利用 Creation Project 新特性，又能兼容 CoCo。

### 3.更多强大功能

SCW 有更易使用的 API，更多高级特性，让你的控件更易于使用。
